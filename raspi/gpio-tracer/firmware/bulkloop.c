/**
 * Copyright (C) 2009 Ubixum, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *
 * This firmware builds on the bulkloop example from external/fx2lib.
 * Data is sampled by continuesly sampling the slave FIFO data lines using a two state
 * GPIF Waveform. The Waveform data is generated using the FX2 GPIF Designer Utility.
 **/
#include <stdio.h>

#include <fx2regs.h>
#include <fx2macros.h>
#include <serial.h>
#include <delay.h>
#include <autovector.h>
#include <lights.h>
#include <setupdat.h>
#include <eputils.h>
#include <gpif.h>

#define SYNCDELAY SYNCDELAY16
#define REARMVAL 0x80
#define REARMEP2() EP2BCL=REARMVAL

#define ENABLE_IBN() NAKIE |= bmIBN; // Ping & combined IN-BULK_NAK (IBN) interrupt enable
#define ENABLE_EP2IBN() IBNIE |= bmEP2IBN; // Inidividual IBN interrupt enable
#define DISABLE_EPxIBN() IBNIE = 0x00;



// Auto generated by GPIF Designer
const char __xdata WaveData[128] =
{
// Wave 0
/* LenBr */ 0x01,     0x01,     0x01,     0x01,     0x01,     0x01,     0x01,     0x07,
/* Opcode*/ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,
/* Output*/ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,
/* LFun  */ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x3F,
// Wave 1
/* LenBr */ 0x01,     0x01,     0x01,     0x01,     0x01,     0x01,     0x01,     0x07,
/* Opcode*/ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,
/* Output*/ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,
/* LFun  */ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x3F,
// Wave 2
/* LenBr */ 0x28,     0xB8,     0x01,     0x01,     0x01,     0x01,     0x01,     0x07,
/* Opcode*/ 0x02,     0x01,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,
/* Output*/ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,
/* LFun  */ 0x00,     0x36,     0x00,     0x00,     0x00,     0x00,     0x00,     0x3F,
// Wave 3
/* LenBr */ 0x01,     0x01,     0x01,     0x01,     0x01,     0x01,     0x01,     0x07,
/* Opcode*/ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,
/* Output*/ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,
/* LFun  */ 0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x00,     0x3F,
};

const char __xdata FlowStates[36] =
{
/* Wave 0 FlowStates */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
/* Wave 1 FlowStates */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
/* Wave 2 FlowStates */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
/* Wave 3 FlowStates */ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const char __xdata InitData[7] =
{
/* Regs  */ 0xC0,0x00,0x00,0x00,0xEE,0xAA,0x00
};



volatile WORD bytes;
volatile __bit gotbuf;
volatile BYTE icount;
volatile __bit got_sud;
DWORD lcount;
__bit on;

void setup() {
  REVCTL=0; // not using advanced endpoint controls

  d2off();
  on=0;
  lcount=0;
  got_sud=FALSE;
  icount=0;
  gotbuf=FALSE;
  bytes=0;

  // renumerate
  RENUMERATE_UNCOND();


  SETCPUFREQ(CLK_48M);
  SETIF48MHZ();
  sio0_init(57600);


  USE_USB_INTS();
  ENABLE_SUDAV();
  ENABLE_IBN();
  ENABLE_EP2IBN();
  ENABLE_SOF();
  ENABLE_HISPEED();
  ENABLE_USBRESET();

  putchar('w');

  // we use EndPoint 2 for bulk transfers to the host
  EP2CFG = bmSIZE | bmTYPE1 | bmDIR | bmVALID | bmBUF;
  SYNCDELAY; //
  // disable all other endpoints
  EP6CFG = ~bmVALID;
  SYNCDELAY;
  EP1INCFG &= ~bmVALID;
  SYNCDELAY;
  EP1OUTCFG &= ~bmVALID;
  SYNCDELAY;
  EP4CFG &= ~bmVALID;
  SYNCDELAY;
  EP8CFG &= ~bmVALID;
  SYNCDELAY;


  // TODO is this needed?
  RESETFIFO(0x02);

  // make it so we enumerate

  EA=1; // global interrupt enable
  printf ( "Done initializing stuff\n" );
}

char gpif_abort_transaction() {
  SYNCDELAY;
  GPIFABORT = 0xFF;
  SYNCDELAY;

  return 0;
}


// -- Auto generated Code by GPIF Designer Utility --
void _gpif_init( void )
{
  IFCONFIG =
    bmIFCLKSRC     |  // IFCLKSRC=1   , FIFOs executes on internal clk source
    bm3048MHZ      |  // xMHz=1       , 48MHz internal clk rate
    bmASYNC        |  // ASYNC=1      , master samples asynchronous
    bmGSTATE       |  // GSTATE=1     , Drive GPIF states out on PORTE[2:0], debug WF
    bmIFGPIF;     // IFCFG[1:0]=10, FX2 in GPIF master mode

  SYNCDELAY;

  gpif_abort_transaction();

  SYNCDELAY;
  // call gpif_init from fx2lib (contains pretty much the default init code generated by gpif designer)
  gpif_init(WaveData, InitData);
}


#define GPIFFLAGFULL 0x02
#define GPIFSTOPONFLAG 0x01
void gpif_endpoint_setup() {
  printf("choosing gpif settings for endpoint 2");
  SYNCDELAY;
  // Select which FIFO Flag should be made available to the Waveform as a control input
  EP2GPIFFLGSEL = GPIFFLAGFULL;
  SYNCDELAY;
  // transition GPIF to done state when FIFO Flag criteria is met
  EP2GPIFPFSTOP = GPIFSTOPONFLAG;
  SYNCDELAY;

  EP2AUTOINLENH = 0x02;
  EP2AUTOINLENL = 0x00;

  // Endpoint 2 FIFO configuration
  EP2FIFOCFG = bmAUTOIN; // enable automatic commit to Serial interface Engine (SIE)
  SYNCDELAY;
}

char gpif_poll_finished() {
  return GPIFIDLECS & 0x80;
}


// starts the gpif sampling routine
char gpif_start_transaction() {
  printf("Starting sampling");
 // the programmed waveform loops indefinitely, until it is manually stopped or a FIFO overflow occurs.
  gpif_set_tc16(1);

  gpif_fifo_read(GPIF_EP2);

  SYNCDELAY;
  gpif_poll_finished();


  return 0;
}

void main() {
  setup();
  SYNCDELAY;
  gpif_endpoint_setup();
  SYNCDELAY;
  _gpif_init();
  SYNCDELAY;
  /* gpif_start_transaction(); */
  SYNCDELAY;

  /* REARMEP2(); */
  d3off();

  while(TRUE) {
    SYNCDELAY16;

    if ( got_sud ) {
      printf ( "Handle setupdata\n" );
      handle_setupdata();
      got_sud=FALSE;
    }
  }
}

// copied routines from setupdat.h
// use default handler from setup.c
BOOL handle_get_descriptor() {
  return FALSE;
}

// value (low byte) = ep
typedef enum {
  VC_EPSTAT = 0xB1,
  VC_START_SAMP
} VENDOR_COMMANDS;


BOOL handle_vendorcommand(BYTE cmd) {

  switch ( cmd ) {

  case VC_EPSTAT:
    {
      __xdata BYTE* pep= ep_addr(SETUPDAT[2]);
      printf ( "ep %02x\n" , *pep );
      if (pep) {
        EP0BUF[0] = *pep;
        EP0BCH=0;
        EP0BCL=1;
        return TRUE;
      }
    }
  case VC_START_SAMP:
    {
      printf("start sampling\n");
      gpif_start_transaction();
      return TRUE;
    }
  default:
    printf ( "Need to implement vendor command: %02x\n", cmd );
  }
  return FALSE;
}

// this firmware only supports 0,0
BOOL handle_get_interface(BYTE ifc, BYTE* alt_ifc) {
  printf ( "Get Interface\n" );
  if (ifc==0) {*alt_ifc=0; return TRUE;} else { return FALSE;}
}


BOOL handle_set_interface(BYTE ifc, BYTE alt_ifc) {
  printf ( "Set interface %d to alt: %d\n" , ifc, alt_ifc );

  if (ifc==0&&alt_ifc==0) {
    // SEE TRM 2.3.7
    // reset toggles
    EP2FIFOCFG = 0;
    SYNCDELAY;

    RESETTOGGLE(0x82);
    SYNCDELAY;
    // only ednpoint 2 is used for now. 2 is configured as in-going EP, therefor set bit 8
    /* RESETTOGGLE(0x86); */

    // restore endpoints to default condition
    RESETFIFO(0x02);
    /* EP2BCL=0x80; */
    /* SYNCDELAY; */
    /* EP2BCL=0X80; */
    /* SYNCDELAY; */
    /* RESETFIFO(0x86); */

    SYNCDELAY;
    EP2FIFOCFG = bmAUTOIN;

    return TRUE;
  } else
    return FALSE;
}

// get/set configuration
BYTE handle_get_configuration() {
  return 1;
}

BOOL handle_set_configuration(BYTE cfg) {
  return cfg==1 ? TRUE : FALSE; // we only handle cfg 1
}

// copied usb jt routines from usbjt.h
void sudav_isr() __interrupt SUDAV_ISR {
  got_sud=TRUE;
  CLEAR_SUDAV();
}

// asserted when host sends data into endpoint which does not contain any data.
void ibn_isr(void) __interrupt IBN_ISR {
  // disable ibn interrupts for all endpoints
  DISABLE_EPxIBN();

  // handling as per p. 94 of fx2 technical specification
  CLEAR_USBINT();

  if(IBNIRQ & bmEP2IBN) {
    // todo
  }

  // clear IRQ bits by writing 1 to each
  IBNIRQ = 0xFF;

  NAKIRQ = bmIBN;
  SYNCDELAY;

  // we only use interrupts for endpoint 2 so only enable them
  ENABLE_EP2IBN();
  SYNCDELAY;
}

__bit on5;
__xdata WORD sofct=0;
void sof_isr () __interrupt SOF_ISR __using 1 {
  ++sofct;
  if(sofct==8000) { // about 8000 sof interrupts per second at high speed
    on5=!on5;
    if (on5) {d5on();} else {d5off();}
    sofct=0;
  }
  CLEAR_SOF();
}

void usbreset_isr() __interrupt USBRESET_ISR {
  handle_hispeed(FALSE);
  CLEAR_USBRESET();
}
void hispeed_isr() __interrupt HISPEED_ISR {
  handle_hispeed(TRUE);
  CLEAR_HISPEED();
}
